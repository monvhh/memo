# 垃圾回收

## 新生代垃圾回收过程

生命周期短
Scavenge算法：空间换时间
cheney算法

一分为二：semi

+ 激活 -> From 空间
+ 未激活 inactive new space -> To 空间

垃圾回收机制：
if 存活，复制到TO空间，结束后，From和To互换

新生代，复制多次后，转移到老生代->晋升
判断条件：

1. 对象经历过一次scavenge

或

2. To空间内存超过25%

## 老生代

### Mark-Sweep 标记清除

    对象是否可访问到->构建跟列表，从根出发找变量，标记为活的
    ->释放无标记的内存块->清除后，内存空间不连续（内存碎片）
    ->Mark Compact

### Mark-Compact 标记整理

清除后整理，将活动对象往堆内存一端移动
标记->整理->清除

### Incremental Marking 增量标记

标记一部分，暂停，回到主线程任务执行，完毕后回到原位置继续标记——>解决阻塞主线程问题
尽少影响主线程任务
Lazy sweeping 延迟清理，增量式整理 incremental compaction

## V8 回收机制

引擎、运行时提供

Node 可配置 --v8-options
新生代内存中单个半空间内存最大/最小值
新生代内存最大值

process.memoryUsage() -> 查看当前node进程所占实际内存大小

对象、闭包->堆
变量->栈

v8 内存结构：

1. 新生代：一半分配内存，另一半，回收时要保留的对象
2. 老生代：指针区 和 数据区——原始数据对象，没有指向其他对象的指针
3. 大对象区
4. 代码区
5. map区
